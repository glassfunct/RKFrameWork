package  com.rekoo.manager{
	import com.rekoo.interfaces.IRKSubscriber;

	/**	 * 消息管理类。	 * @author Administrator	 * 	 */		public final class RKMessageManager	{		private static var _instance:RKMessageManager = null;				/**		 * 消息存储在此处。		 */				private var _observerData:Object={};				public function RKMessageManager(enforcer_:SingletonEnforcer):void		{					}		/**		 * 单例。		 */		public static function get instance():RKMessageManager		{			if (_instance == null)			{				_instance=new RKMessageManager(new SingletonEnforcer());			}						return _instance;		}		/**		 * <b>订阅消息:</b>将需要的消息注册到消息管理类;当该消息用于远程操作时,同时生成并注册对应的RequestKey和ResponseKey。		 * @param protocol_ 协议。		 * @param subscriber_   订阅者,实现 ISubscriber 接口。		 */		public function subscribe(protocol_:String, subscriber_:IRKSubscriber):void		{			var _messageList:Vector.<IRKSubscriber> = null;			//先排重。			if ( _observerData.hasOwnProperty(protocol_) )			{				_messageList = _observerData[protocol_];								for each ( var _suvscriber:IRKSubscriber in _messageList )				{					if ( _suvscriber == subscriber_ )					{						return;					}				}			}			else			{				_messageList = new Vector.<IRKSubscriber>;				_observerData[protocol_] = _messageList;			}						_messageList.push(subscriber_);		}		/**		 * <b>退订消息:</b>退订一个消息,成功调用后,此订阅者将不再收到对应消息的通知。		 * @param protocol_  协议,该订阅者实现 IObserver 接口。		 * @param subscriber 订阅者,此参数有效时,只从指定消息删除该对象的订阅;否则删除指定消息的所有订阅。		 *		 */		public function unsubscribe(protocol_: String, subscriber_:IRKSubscriber = null):Boolean		{			if (subscriber_ == null)			{				if (_observerData.hasOwnProperty(protocol_))				{ 					delete _observerData[protocol_];					return true;				}			}			else			{				var _subLen:int = _observerData[protocol_].length;								for (var i:int = 0; i < _subLen; i++)				{					if (_observerData[protocol_][i] == subscriber_)					{						_observerData[protocol_][i] = null;						//observerData[protocol_].splice(i, 1);						return true;					}				}			}						return false;		}				/**		 * <b>发送消息:</b>调用接受者定义的事件处理程序。		 * @param protocol_: 协议。		 * @param args_ 额外参数。		 */			public function notify(protocol_:String, args_:Array = null):Boolean		{			var _messageList:Vector.<IRKSubscriber> = _observerData[protocol_];						if (_messageList != null)			{				var _flag:Boolean = false;				var _subLen:int = _messageList.length;								for (var _i:int=0; _i < _subLen; _i++)				{					if ( _observerData[protocol_][_i] != null )					{						_observerData[protocol_][_i].notify(protocol_, args_);						_flag = true;					}				}								for ( var _j:int = 0; _j < _subLen; _j ++ )				{					if ( _observerData[protocol_][_j] == null )					{						_observerData[protocol_].splice(_j, 1);						_j --;						_subLen --;					}				}								if ( _subLen == 0 )				{					delete _observerData[protocol_];				}			}						return _flag;		}	}}class SingletonEnforcer {}